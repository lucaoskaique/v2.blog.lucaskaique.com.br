---
layout: post
date: 2024-02-11 11:36:36
image: /assets/img/imagem_2024-02-04_202622872.png
main-class: js
color: '#D6BA32'
tags:
  - javascript
  - coding
  - react
categories:
  - javascript
pt-BR:
  title: 3 Técnicas Pessoais Que Transformaram Minha Carreira em Desenvolvimento
  description: >-
    Sabe quando você começa a codar e só quer que as coisas funcionem? Pois é,
    mas aí você descobre que rola fazer isso de um jeito bem mais top. Tem três
    coisas que, se você começar a usar agora, vão dar um up no seu código
    rapidinho.
  body: "\n![](/assets/img/imagem_2024-02-04_202622872.png \"Evoluindo na Programação: Lições de um Full Stack\")\n\n### **Evoluindo na Programação: Lições de um Full Stack**\n\nHá quase um ano, entrei numa experiência muito divertida no mundo do desenvolvimento, participando ativamente do Dev em Dobro, ajudando no papel de instrutor e mentor. Durante esse período, não apenas compartilhei conhecimentos e esclareci dúvidas, mas também testemunhei o crescimento impressionante de inúmeros alunos, do zero à competência em desenvolvimento web.\n\nEsta jornada reacendeu reflexões sobre meus próprio inicio na programação. Me lembro dos dias em que, sem uma orientação formal, cada linha de código que funcionava era um motivo de celebrar. Essa abordagem \"go horse\" no código, embora divertida, muitas vezes me deixava à deriva em um mar de práticas questionáveis e dúvidas horrendas.\n\nRefletindo sobre essa trajetória, identifiquei três princípios fundamentais que teriam acelerado meu progresso e refinado minha abordagem ao desenvolvimento desde o início. São lições que transcenderam minha experiência com desenvolvimento. Aqui estão elas:\n\n#### **1. Escrevendo Código para Humanos**\n\nNa programação, a verdadeira arte eu vejo que é escrever código que seja facilmente compreendido por outros desenvolvedores. No início, muitos escrevem código pensando na máquina, performace e etc, mas a realidade é que nosso público principal são os colegas de equipe que vão ler, entender e modificar esse código. Simplificar a complexidade e priorizar a clareza não é apenas uma questão de cortesia profissional, mas uma habilidade essencial na construção de sistemas robustos e colaborativos.\n\nEsse conceito, embora pareça básico, foi uma verdadeira mudança de paradigma para mim. No início, minha visão de programação era puramente técnica: eu via o código como um meio de instruir o computador, focando em como \"falar\" com a máquina, todo mundo de todos os cursos e trabalho falavam só sobre performance. Mas, com o tempo, percebi algo fundamental que o código é de dev para dev, não de dev para máquina.\n\nA máquina, no final das contas, vai converte tudo em zeros e uns e não tem a menor preocupação com a legibilidade ou a elegância do código. São os nossos colegas que precisam navegar, entender e, muitas vezes, expandir ou corrigir o que escrevemos.\n\nVamos ilustrar isso com um exemplo prático: a função `groupBy`.\n\nPrimeiro se liga:\n\n```javascript\nconst groupBy = (arr, groupFn) =>\n  arr.reduce(\n    (grouped, obj) => ({\n      ...grouped,\n      [groupFn(obj)]: [...(grouped[groupFn(obj)] || []), obj]\n    }),\n    {}\n  )\n```\n\nAqui, demonstramos que podemos condensar operações complexas em uma única linha. Embora isso possa nos fazer sentir mais experientes, na realidade, torna a compreensão do código muito mais difícil para qualquer pessoa que precise revisá-lo.\n\nAgora, considere esta outra implementação:\n\n```javascript\nconst groupBy = (arr, groupFn) => {\n  const grouped = {}\n  for (const obj of arr) {\n    const groupName = groupFn(obj)\n    if (!grouped[groupName]) {\n      grouped[groupName] = []\n    }\n    grouped[groupName].push(obj)\n  }\n  return grouped\n}\n```\n\nEsse código pode ser lido de cima para baixo, e é possível entender instantaneamente o que acontece em cada linha. Ele pode não ter a mesma \"elegância\" da versão anterior, mas sua legibilidade é imensamente superior. E é justamente isso que valorizamos: um código que qualquer pessoa na equipe possa revisitar no futuro e agradecer pela clareza.\n\nEsse princípio de priorizar a legibilidade não só facilita a manutenção do código como também promove uma cultura de colaboração e aprendizado contínuo entre os desenvolvedores. Portanto, da próxima vez que você se sentar para codar, lembre de que está escrevendo para humanos, não para máquinas.\n\n#### **2. Escondendo Informações Atrás das Cortinas**\n\nUma das maiores revelações que tive foi a eficácia de abstrair detalhes complexos por trás de funções claras e bem definidas. Isso não apenas melhora a legibilidade do código, mas também sua modularidade. Ao encapsular operações complexas, facilitamos a manutenção e incentivamos a reutilização do código.\n\nMinha passagem pelo Dev em Dobro foi mais do que apenas um período de ensino; foi um lembrete constante do poder da educação contínua e do compartilhamento de conhecimento. Ver desenvolvedores emergentes abraçando esses princípios e aplicando-os em seus projetos reforça a crença de que, independentemente de onde começamos, o crescimento contínuo é sempre possível.\n\nEspero que compartilhando essas lições, possa inspirar outros a refletirem sobre suas práticas de codificação e a buscarem sempre a evolução. Afinal, o desenvolvimento de software é uma jornada sem fim, repleta de aprendizados constantes e oportunidades de melhorar não apenas nossos códigos, mas também a nós mesmos como profissionais e mentores.\n\nPara quem já mexeu com React, os hooks são um exemplo perfeito desse princípio:\n\n```javascript\nimport React, { useState, useEffect } from \"react\"\n\nfunction FriendListItem(props) {\n  const [isOnline, setIsOnline] = useState(null)\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline)\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)\n    }\n  })\n\n  return (\n    <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>\n  )\n}\n```\n\nNesse caso, temos um componente que mostra um item de lista com a cor dinâmica baseada no status do amigo. Apesar de funcionar direitinho, esse código esconde dentro dele lógicas que não têm muito a ver com o propósito principal do componente `FriendListItem`.\n\nSe a gente pegar essa lógica e criar um hook customizado chamado `useFriendStatus`, dá para simplificar o componente assim:\n\n```javascript\nimport React, { useState, useEffect } from \"react\"\n\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id)\n\n  return (\n    <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>\n  )\n}\n```\n\nIsso traz dois benefícios bem legais:\n\n1. A gente pode reutilizar a lógica do `useFriendStatus` em outros lugares.\n2. Simplificamos nosso componente para mostrar apenas o que realmente importa para sua funcionalidade.\n\nFalando de um jeito mais amplo, o princípio de esconder informações é sobre colocar detalhes irrelevantes para trás de funções abstratas. Assim, a gente não precisa se preocupar com os detalhes de implementação dentro da função abstrata - podemos focar mais no que ela faz, ou seja, no nome da função que indica seu propósito.\n\nDessa forma, o código fica mais limpo, fácil de entender e manter, liberando mais tempo para a gente focar na solução dos problemas em vez de decifrar o que cada pedaço do código está fazendo.\n\n#### **3. “Return Early” em Vez de Usar Coisas Aninhadas**\n\nA ultima dica tem a ver especialmente com lidar com validações em rotas de API, é tentador cair na armadilha das condições aninhadas. O padrão \"retorne cedo\" simplifica a lógica, evitando a complexidade e melhorando a legibilidade do código. Adotar essa prática não só torna o código mais limpo, mas também facilita sua manutenção a longo prazo.\n\nVeja só como geralmente a coisa começa:\n\n```javascript\nexport const handler = async (req, res) => {\n  if (req.method === \"POST\" || req.method === \"OPTIONS\") {\n    const email = validateEmail(req.body.email)\n    if (email) {\n      const user = findUserByEmail(email)\n      if (user) {\n        return res.status(200).json({ user })\n      } else {\n        return res.status(404).json({ message: \"Usuário não encontrado\" })\n      }\n    } else {\n      return res.status(422).json({ message: \"Faltou o email\" })\n    }\n  } else {\n    return res.status(405).json({ message: \"Esse método não rola\" })\n  }\n}\n```\n\nEsse código pode não estar super complexo, mas já começa a ficar um pouco enrolado. O grande truque aqui é que, em vez de seguir uma linha reta, parece que a gente tá fazendo zig-zag pra entender o fluxo.\n\nAgora, que tal a gente tentar um jeito diferente de escrever isso, utilizando o que chamamos de \"Padrão de Retorno Antecipado\"? Esse padrão ajuda a cortar o caminho quando algo não está nos conformes, deixando o fluxo mais lógico e direto.\n\nOlha só como poderia ficar:\n\n```javascript\nexport const handler = async (req, res) => {\n  if (req.method !== \"POST\" && req.method !== \"OPTIONS\") {\n    return res.status(405).json({ message: \"Esse método não rola\" })\n  }\n\n  const email = validateEmail(req.body.email)\n  if (!email) {\n    return res.status(422).json({ message: \"Faltou o email\" })\n  }\n\n  const user = findUserByEmail(email)\n  if (!user) {\n    return res.status(404).json({ message: \"Usuário não encontrado\" })\n  }\n\n  return res.status(200).json({ user })\n}\n```\n\nDessa forma, o código fica mais limpo e a gente consegue entender o que tá acontecendo passo a passo, de uma maneira bem mais tranquila. Ao invés de um monte de condicionais aninhados, a gente vai direto ao ponto e trata cada caso separadamente, deixando o caminho livre até chegar no resultado que a gente quer lá no final.\n\n---\n\nE\uFEFFspero que essas dicas tenham sido úteis e que essas pequenas dicas te engrandeçam na sua jornada de estudos\n"
en:
  title: 3 Personal Techniques That Transformed My Development Career
  description: >-
    You know when you start coding and just want things to work? Well, there are
    three things that, if you start using them now, will level up your code
    quickly
  body: "\n![](/assets/img/imagem_2024-02-04_202622872.png \"Evoluindo na Programação: Lições de um Full Stack\")\n\n### **Evoluindo na Programação: Lições de um Full Stack**\n\nHá quase um ano, entrei numa experiência muito divertida no mundo do desenvolvimento, participando ativamente do Dev em Dobro, ajudando no papel de instrutor e mentor. Durante esse período, não apenas compartilhei conhecimentos e esclareci dúvidas, mas também testemunhei o crescimento impressionante de inúmeros alunos, do zero à competência em desenvolvimento web.\n\nEsta jornada reacendeu reflexões sobre meus próprio inicio na programação. Me lembro dos dias em que, sem uma orientação formal, cada linha de código que funcionava era um motivo de celebrar. Essa abordagem \"go horse\" no código, embora divertida, muitas vezes me deixava à deriva em um mar de práticas questionáveis e dúvidas horrendas.\n\nRefletindo sobre essa trajetória, identifiquei três princípios fundamentais que teriam acelerado meu progresso e refinado minha abordagem ao desenvolvimento desde o início. São lições que transcenderam minha experiência com desenvolvimento. Aqui estão elas:\n\n#### **1. Escrevendo Código para Humanos**\n\nNa programação, a verdadeira arte eu vejo que é escrever código que seja facilmente compreendido por outros desenvolvedores. No início, muitos escrevem código pensando na máquina, performace e etc, mas a realidade é que nosso público principal são os colegas de equipe que vão ler, entender e modificar esse código. Simplificar a complexidade e priorizar a clareza não é apenas uma questão de cortesia profissional, mas uma habilidade essencial na construção de sistemas robustos e colaborativos.\n\nEsse conceito, embora pareça básico, foi uma verdadeira mudança de paradigma para mim. No início, minha visão de programação era puramente técnica: eu via o código como um meio de instruir o computador, focando em como \"falar\" com a máquina, todo mundo de todos os cursos e trabalho falavam só sobre performance. Mas, com o tempo, percebi algo fundamental que o código é de dev para dev, não de dev para máquina.\n\nA máquina, no final das contas, vai converte tudo em zeros e uns e não tem a menor preocupação com a legibilidade ou a elegância do código. São os nossos colegas que precisam navegar, entender e, muitas vezes, expandir ou corrigir o que escrevemos.\n\nVamos ilustrar isso com um exemplo prático: a função `groupBy`.\n\nPrimeiro se liga:\n\n```javascript\nconst groupBy = (arr, groupFn) =>\n  arr.reduce(\n    (grouped, obj) => ({\n      ...grouped,\n      [groupFn(obj)]: [...(grouped[groupFn(obj)] || []), obj]\n    }),\n    {}\n  )\n```\n\nAqui, demonstramos que podemos condensar operações complexas em uma única linha. Embora isso possa nos fazer sentir mais experientes, na realidade, torna a compreensão do código muito mais difícil para qualquer pessoa que precise revisá-lo.\n\nAgora, considere esta outra implementação:\n\n```javascript\nconst groupBy = (arr, groupFn) => {\n  const grouped = {}\n  for (const obj of arr) {\n    const groupName = groupFn(obj)\n    if (!grouped[groupName]) {\n      grouped[groupName] = []\n    }\n    grouped[groupName].push(obj)\n  }\n  return grouped\n}\n```\n\nEsse código pode ser lido de cima para baixo, e é possível entender instantaneamente o que acontece em cada linha. Ele pode não ter a mesma \"elegância\" da versão anterior, mas sua legibilidade é imensamente superior. E é justamente isso que valorizamos: um código que qualquer pessoa na equipe possa revisitar no futuro e agradecer pela clareza.\n\nEsse princípio de priorizar a legibilidade não só facilita a manutenção do código como também promove uma cultura de colaboração e aprendizado contínuo entre os desenvolvedores. Portanto, da próxima vez que você se sentar para codar, lembre de que está escrevendo para humanos, não para máquinas.\n\n#### **2. Escondendo Informações Atrás das Cortinas**\n\nUma das maiores revelações que tive foi a eficácia de abstrair detalhes complexos por trás de funções claras e bem definidas. Isso não apenas melhora a legibilidade do código, mas também sua modularidade. Ao encapsular operações complexas, facilitamos a manutenção e incentivamos a reutilização do código.\n\nMinha passagem pelo Dev em Dobro foi mais do que apenas um período de ensino; foi um lembrete constante do poder da educação contínua e do compartilhamento de conhecimento. Ver desenvolvedores emergentes abraçando esses princípios e aplicando-os em seus projetos reforça a crença de que, independentemente de onde começamos, o crescimento contínuo é sempre possível.\n\nEspero que compartilhando essas lições, possa inspirar outros a refletirem sobre suas práticas de codificação e a buscarem sempre a evolução. Afinal, o desenvolvimento de software é uma jornada sem fim, repleta de aprendizados constantes e oportunidades de melhorar não apenas nossos códigos, mas também a nós mesmos como profissionais e mentores.\n\nPara quem já mexeu com React, os hooks são um exemplo perfeito desse princípio:\n\n```javascript\nimport React, { useState, useEffect } from \"react\"\n\nfunction FriendListItem(props) {\n  const [isOnline, setIsOnline] = useState(null)\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline)\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)\n    }\n  })\n\n  return (\n    <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>\n  )\n}\n```\n\nNesse caso, temos um componente que mostra um item de lista com a cor dinâmica baseada no status do amigo. Apesar de funcionar direitinho, esse código esconde dentro dele lógicas que não têm muito a ver com o propósito principal do componente `FriendListItem`.\n\nSe a gente pegar essa lógica e criar um hook customizado chamado `useFriendStatus`, dá para simplificar o componente assim:\n\n```javascript\nimport React, { useState, useEffect } from \"react\"\n\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id)\n\n  return (\n    <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>\n  )\n}\n```\n\nIsso traz dois benefícios bem legais:\n\n1. A gente pode reutilizar a lógica do `useFriendStatus` em outros lugares.\n2. Simplificamos nosso componente para mostrar apenas o que realmente importa para sua funcionalidade.\n\nFalando de um jeito mais amplo, o princípio de esconder informações é sobre colocar detalhes irrelevantes para trás de funções abstratas. Assim, a gente não precisa se preocupar com os detalhes de implementação dentro da função abstrata - podemos focar mais no que ela faz, ou seja, no nome da função que indica seu propósito.\n\nDessa forma, o código fica mais limpo, fácil de entender e manter, liberando mais tempo para a gente focar na solução dos problemas em vez de decifrar o que cada pedaço do código está fazendo.\n\n#### **3. “Return Early” em Vez de Usar Coisas Aninhadas**\n\nA ultima dica tem a ver especialmente com lidar com validações em rotas de API, é tentador cair na armadilha das condições aninhadas. O padrão \"retorne cedo\" simplifica a lógica, evitando a complexidade e melhorando a legibilidade do código. Adotar essa prática não só torna o código mais limpo, mas também facilita sua manutenção a longo prazo.\n\nVeja só como geralmente a coisa começa:\n\n```javascript\nexport const handler = async (req, res) => {\n  if (req.method === \"POST\" || req.method === \"OPTIONS\") {\n    const email = validateEmail(req.body.email)\n    if (email) {\n      const user = findUserByEmail(email)\n      if (user) {\n        return res.status(200).json({ user })\n      } else {\n        return res.status(404).json({ message: \"Usuário não encontrado\" })\n      }\n    } else {\n      return res.status(422).json({ message: \"Faltou o email\" })\n    }\n  } else {\n    return res.status(405).json({ message: \"Esse método não rola\" })\n  }\n}\n```\n\nEsse código pode não estar super complexo, mas já começa a ficar um pouco enrolado. O grande truque aqui é que, em vez de seguir uma linha reta, parece que a gente tá fazendo zig-zag pra entender o fluxo.\n\nAgora, que tal a gente tentar um jeito diferente de escrever isso, utilizando o que chamamos de \"Padrão de Retorno Antecipado\"? Esse padrão ajuda a cortar o caminho quando algo não está nos conformes, deixando o fluxo mais lógico e direto.\n\nOlha só como poderia ficar:\n\n```javascript\nexport const handler = async (req, res) => {\n  if (req.method !== \"POST\" && req.method !== \"OPTIONS\") {\n    return res.status(405).json({ message: \"Esse método não rola\" })\n  }\n\n  const email = validateEmail(req.body.email)\n  if (!email) {\n    return res.status(422).json({ message: \"Faltou o email\" })\n  }\n\n  const user = findUserByEmail(email)\n  if (!user) {\n    return res.status(404).json({ message: \"Usuário não encontrado\" })\n  }\n\n  return res.status(200).json({ user })\n}\n```\n\nDessa forma, o código fica mais limpo e a gente consegue entender o que tá acontecendo passo a passo, de uma maneira bem mais tranquila. Ao invés de um monte de condicionais aninhados, a gente vai direto ao ponto e trata cada caso separadamente, deixando o caminho livre até chegar no resultado que a gente quer lá no final.\n\n---\n\nE\uFEFFspero que essas dicas tenham sido úteis e que essas pequenas dicas te engrandeçam na sua jornada de estudos\n"
---

